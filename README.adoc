= riscv-tools image:https://travis-ci.org/riscv/riscv-tools.svg?branch=master["Build Status",link="https://travis-ci.org/riscv/riscv-tools"]
:toc: macro
:toclevels: 1



The RISC-V toolchain is a set of tools for developing software on the
https://riscv.org[RISC-V] instruction set architecture; it consists of
the following components:

https://github.com/riscv/riscv-gnu-toolchain[riscv-gnu-toolchain]::
    a RISC-V cross-compiler

https://github.com/riscv/riscv-fesvr[riscv-fesvr]::
    a "front-end" server that services calls between the host and target
    processors on the Host-Target InterFace (HTIF)

https://github.com/riscv/riscv-isa-sim[riscv-isa-sim]::
    the ISA simulator

https://github.com/riscv/riscv-opcodes[riscv-opcodes]::
    the enumeration of all RISC-V opcodes executable by the simulator

https://github.com/riscv/riscv-pk[riscv-pk]::
    a proxy kernel that services system calls generated by code built and
    linked with the RISC-V Newlib port

https://github.com/riscv/riscv-tests[riscv-tests]::
    a set of assembly tests and benchmarks

This repo provides two options: one installs the all of the `riscv-tools`
with the <<what_s_newlib,Newlib>> library using a proxy kernel
(`riscv-pk`) and the other installs only a subset of the `riscv-tools`
with Glibc using the Linux kernel.

Both options share a common setup but diverge around the time the
`build.sh` script is executed; simply follow this guide from the start
and we will let you know what to do based on the path you've chosen.

toc::[]

== Quickstart

    $ git submodule update --init --recursive
    $ export RISCV=/path/to/install/the/riscv/toolchain
    $ ./build.sh

=== Dependencies

Ubuntu:

    # apt-get install autoconf automake autotools-dev curl device-tree-compiler libmpc-dev libmpfr-dev libgmp-dev libusb-1.0-0-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev device-tree-compiler pkg-config

Fedora:

    # dnf install autoconf automake @development-tools curl dtc libmpc-devel mpfr-devel gmp-devel gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib-devel

OS X:

    # brew install dtc gawk gnu-sed gmp mpfr libmpc isl wget automake md5sha1sum

NOTE: For OS X, you can also install the tools with
https://github.com/riscv/homebrew-riscv[homebrew-riscv]. This repo will build
with Apple's command-line developer tools (clang) in addition to gcc.

== Meta-installation Notes

=== Running Shell Commands

Any instruction to execute in your terminal will look like this (where
`$` is the shell prompt -- i.e., don't type it):

    $ echo "execute this"

Commands requiring superuser privileges (e.g., with `sudo`) will be
prefixed with an octothorpe (`#`):

    # echo "root demands it!"

You will only need this if you want to install to system directories
such as `/usr/bin`.

=== C++11 Compiler Support

Building `riscv-tools` requires a compiler with support for C++11 (e.g.,
GCC >= 4.8). To use a compiler different than your system default, set
the `CC` and `CXX` environment variables before running the `build.sh`
script:

    $ CC=gcc-4.8 CXX=g++-4.8 ./build.sh

=== The Standard Build Unit

To gauge how long it may take to build the various components of the
packages in this repo, build times have been provided in terms of the
Standard Build Unit (SBU), as coined by Gerard Beekmans in his immensely
useful http://www.linuxfromscratch.org[Linux From Scratch] website.

On an Intel Xeon Dual Quad-core server with 48 GiB RAM, I achieved the
following build time for `binutils`: 38.64 seconds. Thus, *38.64 seconds
= 1 SBU*. (EECS members at the University of California, Berkeley: I
used the `s141.millennium` server.)

As a point of reference, my 2007 MacBook with an Intel Core 2 Duo and 1
GiB RAM has 100.1 seconds to each SBU. Building
`riscv64-unknown-linux-gnu-gcc`, unsurprisingly, took about an hour.

Items marked as "optional" are not included in this measurement.

=== Obtaining and Compiling the Sources (7.87 SBU)

Let's start by defining the directory in which we will install all of
the necessary programs, let's call it `TOP` and go there:

    $ export TOP=/nice/big/directory
    $ cd $TOP

Now clone the `riscv-tools` repository:

    $ git clone https://github.com/riscv/riscv-tools.git

This command will bring in only references to the repositories that we
will need. We rely on Git's submodule system to take care of resolving
the references. Enter the newly-created riscv-tools directory and
instruct Git to update its submodules.

    $ cd riscv-tools
    $ git submodule update --init --recursive

Before we start the installation, we need to set the `RISCV` environment
variable. This variable is used throughout the process to identify where
to install the various `riscv-tools`.

    $ export RISCV=$TOP/riscv

If the `RISCV` binary subdirectory is not already in your `PATH`
environment variable, add it now:

    $ export PATH=$PATH:$RISCV/bin

== pk/Newlib Installation

NOTE: Follow the instructions in this section only if you want to use
Newlib and the proxy kernel; otherwise, skip down to the next section
where we use Glibc with the Linux kernel.

With everything else set up, run the `build.sh` script:

    $ ./build.sh

=== Testing Your Toolchain

Now that you have a toolchain, it'd be a good idea to test it on the
quintessential "Hello world!" program. I'll use a long-winded `echo`
command.

    $ echo -e '#include <stdio.h>\n int main(void) { printf("Hello world!\\n"); return 0; }' > hello.c

Then, build your program with `riscv64-unknown-elf-gcc`.

    $ riscv64-unknown-elf-gcc -o hello hello.c

When you're done, you may want to do `./hello` --- but not so fast. We
can't even run `spike hello`, because our "Hello world!" program
involves a system call which couldn't be handled by our host x86 system.
We'll have to run the program within the proxy kernel, which itself is
run by `spike`, the RISC-V architectural simulator. Run this command to
execute your "Hello world!" program:

    $ spike pk hello

The RISC-V architectural simulator, `spike`, takes as its argument the
path of the binary to run. Then, `pk` receives as _its_ argument the
name of the program you want to run.

If this does not behave as expected, see the <<Troubleshooting>> section
below. Otherwise, you're all set to develop on the RISC-V instruction
set architecture with Newlib and the proxy kernel!

== Linux/Glibc Installation

NOTE: This section is only required for those insterested in
developing for RISC-V on the Linux kernel with Glibc.

=== Installing the RISC-V simulator (0.40 SBU)

Instead of building all of the tools in the `riscv-tools` set, we only
need to build `riscv-fesvr` and `riscv-isa-sim`. These are the two
components necessary to simulate RISC-V binaries on the host machine.

NOTE: We will also need to build `riscv64-unknown-linux-gnu-gcc`, but
this involves modifiying the build procedure for
`riscv64-unknown-elf-gcc`; if you want to build the full toolchain for
later use, run `build.sh` without any arguments.

Let's build only the tools we need:

    $ ./build.sh fesvr isa-sim

=== Building `riscv64-unknown-linux-gnu-gcc` (11.41 SBU)

`riscv64-unknown-linux-gnu-gcc` is the name of the cross-compiler used
to build binaries linked to the GNU C Library (`glibc`) instead of the
Newlib library.

Enter the `riscv-gnu-toolchain` subdirectory and run the configure
script to generate the Makefile.

    $ cd $TOP/riscv-tools/riscv-gnu-toolchain
    $ ./configure --prefix=$RISCV

These instructions will place your `riscv64-unknown-linux-gnu-gcc` tools
in the same installation directory as the `riscv64-unknown-elf-gcc` tool
installed earlier.

Run the `linux` make target to start the build process:

    $ make linux

=== Building the Linux Kernel (0.40 + Îµ SBU)

==== Obtaining the Kernel Sources

We are finally poised to bring in the Linux kernel sources. Change out
of the `riscv-tools/riscv-gnu-toolchain` directory and clone the
`riscv-linux` repository.

    $ cd $TOP
    $ git clone https://github.com/riscv/riscv-linux.git

==== Configuring the Linux Kernel

The Linux kernel is seemingly infinitely-configurable. However, with the
current development status of RISC-V, there aren't that many devices or
options to tweak. So starting with a default configuration should work
out-of-the-box with the ISA simulator.

    $ cd riscv-linux
    $ make ARCH=riscv defconfig

If you want to edit the configuration, you can use a text-based GUI
(ncurses) to edit the configuration:

    $ make ARCH=riscv menuconfig

Among other things, we have enabled by default procfs, ext2, and the
HTIF virtualized devices (a block driver and console).

NOTE: In development, it can be very useful to enable "early printk",
which will print messages to the console if the kernel crashes very
early. You can access this option at "Early printk" in the "Kernel
hacking" submenu.

Once you're satisfied with your configuration, begin building the
kernel.

NOTE: to build the RISC-V kernel, you _must_ set the `ARCH` variable
to `riscv` in each invocation of `make`.

If you want to speed up the process, you can pass the `-j[number]`
option to use `[number]` threads.

    $ make -j16 ARCH=riscv

Congratulations! You've just cross-compiled the Linux kernel for RISC-V.
However, there are a few more things to take care of before we boot it.

=== Building BusyBox (0.26 SBU)

We currently develop with BusyBox, an unbelievably useful set of
utilities that all compile into one multi-use binary (of which, we only
need its `init` applet). We use the https://www.busybox.net[BusyBox]
source code without modifications.

First, obtain and untar the source:

    $ curl -L http://busybox.net/downloads/busybox-1.26.2.tar.bz2 | tar xjf -

Then, enter the directory and turn off every configuration option:

    $ cd busybox-1.26.2
    $ make allnoconfig

Now, we will need to change the cross-compiler and set the build to
"static" (if desired, you can make it dynamic, but you'll have to copy
some libraries later). We will also enable the `init`, `ash`, and
`mount` applets. Also, disable job control for `ash` when the drop down
menu for `ash`'s suboptions appear.

Enter the configuration interface,

    $ make menuconfig

and change the following options:

`CONFIG_STATIC=y`::
    BusyBox Settings â Build Options â Build BusyBox as a static binary (no shared libs)
`CONFIG_CROSS_COMPILER_PREFIX=riscv64-unknown-linux-gnu-`::
    BusyBox Settings â Build Options â Cross Compiler prefix
`CONFIG_FEATURE_INSTALLER=y`::
    BusyBox Setting â General Configuration â Support --install [-s] to install applet links at runtime
`CONFIG_INIT=y`::
    Init utilities â init
`CONFIG_ASH=y`::
    Shells â ash 
`CONFIG_ASH_JOB_CONTROL=n`::
    Shells â Ash â Job control
`CONFIG_MOUNT=y`::
    Linux System Utilities â mount
`CONFIG_FEATURE_USE_INITTAB=y`::
    Init Utilities â Support reading an inittab file

Once you've finished, compile BusyBox.

TIP: You don't need to specify `ARCH`, because we've passed the name of the
cross-compiler prefix.

    $ make -j16

Once that completes, you now have a BusyBox binary cross-compiled to run
on RISC-V. Now we'll need a way for the kernel to access the binary, and
we'll use a root disk image for that. Before we proceed, change back
into the directory with the Linux sources.

    $ cd $TOP/linux-3.14.33

=== Creating a Root Disk Image

We use an initramfs to store our binaries (like BusyBox, for example).

To create an initramfs, there are a few directories that you should
have:

* `/bin`
* `/dev`
* `/etc`
* `/lib`
* `/proc`
* `/sbin`
* `/tmp`
* `/usr`

So create them:

    $ mkdir root
    $ cd root
    $ mkdir -p bin etc dev lib proc sbin sys tmp usr/{bin,lib,sbin}

Then, place the BusyBox executable we just compiled in `root/bin`.

    $ cp $TOP/busybox-1.26.2/busybox bin

If you have built BusyBox statically, that will be all that's needed. If
you want to build BusyBox dynamically, you will need to follow a
slightly different procedure, described in the Optional Commands section
below.

We will also need to prepare an initialization table in the aptly-named
file `inittab`, placed in `root/etc`.

.etc/inittab
    ::sysinit:/bin/busybox mount -t proc proc /proc            # <1>
    ::sysinit:/bin/busybox mount -t tmpfs tmpfs /tmp           # <2>
    ::sysinit:/bin/busybox mount -o remount,rw /dev/htifblk0 / # <3>
    ::sysinit:/bin/busybox --install -s                        # <4>
    /dev/console::sysinit:-/bin/ash                            # <5>

<1> Mounts the procfs filesystem onto `/proc`.
<2> Does similarly for tmpfs.
<3> Mounts the HTIF-virtualized block device (`htifbd`) onto root.
<4> Installs the various BusyBox applet symbolic links in `/bin`
and elsewhere to make it more convenient to run them.
<5> Opens up an `ash` shell on the HTIF-virtualized TTY (`console`,
mapped to `ttyHTIF`) for a connection.

If you would like to use `getty` instead, change line 5:

    $ head -n5 etc/inittab
    ::respawn:/bin/busybox getty 38400 ttyHTIF0

Once you've booted Linux and created the symlinks with line 4, they will
persist between boots of the Linux kernel. This will cause a bunch of
unsightly errors in every subsequent boot of the kernel. At the next
boot, comment out line 4.

Also, we will need to create a symbolic link to `bin/busybox` for `init`
to work.

    $ ln -s ../bin/busybox sbin/init
    $ ln -s sbin/init init

We'll also need a character device for the console:

    # mknod dev/console c 5 1

We are ready to create our initramfs:

    $ find . | cpio --quiet -o -H newc > <riscv-linux>/rootfs.cpio

Configure linux to embed the created cpio archive:

    $ cd $TOP/riscv-linux
    $ make ARCH=riscv menuconfig

Enter to General Setup, mark "Initial RAM filesystem and RAM disk". Then
go to the option "Initramfs source file" and press enter to change it to
"rootfs.cpio". Then Exit all the way back and save to .config.

Don't forget to rebuild `riscv-linux` and `riscv-pk`!

    $ cd $TOP/riscv-linux
    $ make -j4 ARCH=riscv vmlinux
    $ cd $TOP/riscv-tools/riscv-pk/build
    $ rm -rf *
    $ ../configure --prefix=$RISCV --host=riscv64-unknown-linux-gnu --with-payload=<riscv-linux>/vmlinux
    $ make
    $ make install

Now, we're ready to boot a most basic kernel, with a shell. Invoke
`spike` to use the `bbl` binary to run the `vmlinux` compiled Linux
kernel.

    $ spike bbl vmlinux

If there are no problems, an `ash` prompt will appear after the boot
process completes. It will be pretty useless without the usual plethora
of command-line utilities, but you can add them as BusyBox applets. Have
fun!

To exit the simulator, hit `Ctrl-C`.

NOTE: If you want to reuse your disk image in a subsequent boot of the
kernel, remember to remove (or comment out) the line that creates the
symbolic links to BusyBox applets. Otherwise, it will generate several
(harmless) warnings in each subsequent boot.

== Optional Commands

Depending on your system, you may have to execute a few more shell
commands or execute them differently. It's not too useful if you've
arrived here after reading the main text of the document; it's best that
you're referred here instead.

=== Installing a Fresh Copy of the Linux Headers

If you (or someone you know) has changed the Linux headers, you'll need
to install a new version to your system root before you build
`riscv64-unknown-linux-gnu-gcc` to make sure the kernel and the C
library agree on their interfaces. (Note that you'll need to pull in the
Linux kernel sources before you perform these steps. If you haven't, do
so now.)

First, go to the Linux directory and perform a headers check:

    $ cd $TOP/linux-3.14.33 $ make ARCH=riscv headers_check

Once the headers have been checked, install them.

    $ make ARCH=riscv headers_install INSTALL_HDR_PATH=$RISCV/sysroot64/usr

(Substitute the path specified by `INSTALL_HDR_PATH` if so desired.)

=== Using Filesystem in Userspace (FUSE) to Create a Disk Image

If you are unable (or unwilling) to use `mount` to mount the
newly-created disk image for modification, and you also have Filesystem
in Userspace (FUSE), you can use these commands to modify your disk
image.

First, create a folder as your mount point.

    $ mkdir mnt

Then, mount the disk image with FUSE. The `-o +rw` option is considered
*experimental* by FUSE developers, and may corrupt your disk image. If
you experience strange behaviors in your disk image, you might want to
delete your image and make a new one. Continuing, mount the disk:

    $ fuseext2 -o rw+ root.bin mnt

Modify the disk image as described, but remember to unmount the disk
using FUSE, not `umount`:

    $ fusermount -u mnt

=== Building BusyBox as a Dynamically-Linked Executable

If you want to conserve space on your root disk, or you want to support
dynamically-linked binaries, you will want to build BusyBox as a
dynamically-linked executable. You'll need to have these libraries:

 * `libc.so.6`, the C library
 * `ld.so.1`, the run-time dynamic linker

If BusyBox calls for additional libraries (e.g.`libm`), you will need to
include those as well.

These were built when we compiled `riscv64-unknown-linux-gnu-gcc` and
were placed in `$RISCV/sysroot64`. So, mount your root disk (if not
mounted already), cd into it, and copy the libraries into `lib`:

    $ cp $RISCV/sysroot64/lib/libc.so.6 lib/
    $ cp $RISCV/sysroot64/lib/ld.so.1 lib/

That's it for the libraries. Go back to the BusyBox configuration and
set BusyBox to be built as a dynamically-linked binary by unchecking the
`CONFIG_STATIC` box in the menuconfig interface.

* `CONFIG_STATIC=n`, listed as "Build BusyBox as a static binary (no
shared libs)" in BusyBox Settings â Build Options

To make things a little faster, I've used a bit of `sed` magic instead.

    $ cd $TOP/busybox-1.26.2
    $ sed -i 's/CONFIG_STATIC=y/# CONFIG_STATIC is not set/' .config

Then, rebuild and reinstall BusyBox into `mnt/bin`.

    $ make -j16
    $ cd $TOP/linux-3.14.33/mnt
    $ cp $TOP/busybox-1.26.2/busybox bin

== Troubleshooting

Most of the errors below were seen when trying to build `riscv-tools` on
CentOS linux distribution with nfs file-system.

=== C++11 is not supported, although gcc is updated

This problem occured due to old OS installation repository. A possible
solution for CentOS distribution:

    $ wget http://people.centos.org/tru/devtools-2/devtools-2.repo -O /etc/yum.repos.d/devtools-2.repo
    # yum upgrade
    # yum install devtoolset-2-gcc devtoolset-2-binutils devtoolset-2-gcc-c++
    $ scl enable devtoolset-2 bash

Last operation will open a shell. Try to run `build.sh` from within this
shell.

=== âerror: Building GCC requires GMP 4.2+, MPFR 2.4.0+ and MPC 0.8.0+â

Try the following:

    $ cd <riscv-tools>/riscv-gnu-toolchain/riscv-gcc
    $ contrib/download_prerequisites
    # yum install gmp gmp-devel mpfr mpfr-devel libmpc libmpc-devel

Also try to follow the instructions of link:#c++11-problem[C++11 is not
supported].

=== Build script got stuck on "Installing project riscv-fesvr"

That's a very simple problem of output redirection. The solution is to
open the /build.common file and change the following line:

    $MAKE install >> build.log

to:

    $MAKE install | tee install.log

Then when you run the build script, you will see requests to press y to
continue which were hidden before. Just follow the instructions.

=== Problems with "flock"

Some filesystems don't support flock, e.g. nfs (you can check your
filesystem by `df -Th`). Look for "+flock $(SYSROOT)/.lock" in the
following files and delete them:

 * `riscv-tools/riscv-gnu-toolchain/Makefile`
 * `riscv-tools/riscv-gnu-toolchain/Makefile.in`
 * `riscv-tools/riscv-gnu-toolchain/build/Makefile`

Avoid building with concurrency (i.e. avoid running make with the -j
flag).

=== "These critical programs are missing or too old: make"

Not sure why, but gmake doesn't work well for the riscv-tools build in
some platforms. In order to use make instead of gmake, open the file
`<riscv-tools>/riscv-gnu-toolchain/riscv-glibc/configure` and replace
the following line:

    for ac_prog in gnumake gmake make

with:

    for ac_prog in gnumake make gmake

=== "Operation not permitted" when trying to create character device

This may occur when running the following command:

    # mknod dev/console c 5 1

Even if you have sudo permissions, you may still see this message in
some filesystem (e.g. nfs). You can create a virtual drive by:

    $ dd if=/dev/zero of=root.bin bs=1M count=64
    $ mkfs.ext2 -F root.bin
    $ chmod 777 root.bin
    $ mkdir mnt
    # mount -o loop root.bin mnt

If the `mkfs.ext2` command not found, try instead:

    $ /sbin/mkfs.ext2 -F root.bin

Copy the contents in the above created root directory into the new mnt
directory and continue to create the cpio archive with the mnt directory
instead of the root directory.

When finished, you may unmount by:

    $ cd ..
    # umount root.bin

=== compiler-gcc6.h not found

Use newer linux version for RISC-V. You can find it in
https://github.com/riscv/riscv-linux[riscv-linux]. Notice that similar problems
as detailed here may occur, so don't forget to check this problem list in case
of problems.

=== Error on build about "mcmodel=medany"

Such error may occur in one of the stages that requires the RISC-V gcc
compiler. Some build stages use the default x86 gcc compiler installed
on the x86 machine to compile if the RISC-V gcc not found. Some possible
cases for that:

 * RISC-V compiler is not built.
 * $RISCV/bin is not in $PATH (Use "setenv PATH $RISCV/bin" or similar
export command to add it to path).
 * RISC-V compiler has been built but for the wrong variant (built for
newlib and not for linux, 32/64 bit variant issue...).
 * gcc path is wrong. For example, if
"CONFIG_CROSS_COMPILER_PREFIX=riscv-linux-" is used in the Busybox build
configuration instead of
"CONFIG_CROSS_COMPILER_PREFIX=riscv64-unknown-linux-gnu-" but the RISC-V
compiler is built into riscv64-unknown-linux-gnu-gcc, the busybox
configurator will not find the correct gcc and will use the x86 as
default. Similar problem may occur when compiling
`riscv-pk` with a wrong --host argument.

=== Spike exits immediately with "This is bbl's dummy_payload" message

`riscv-pk` should be rebuilt with --with-payload flag points to the
compiled vmlinux:

    $ cd $TOP/riscv-tools/riscv-pk/build
    $ rm -rf *
    $ ../configure --prefix=$RISCV --host=riscv64-unknown-linux-gnu --with-payload=<riscv-linux>/vmlinux
    $ make
    $ make install

== FAQ

=== What's Newlib?

https://www.sourceware.org/newlib/[Newlib] is a "C library intended for
use on embedded systems." It has the advantage of not having so much cruft
as Glibc at the obvious cost of incomplete support (and idiosyncratic
behavior) in the fringes. The porting process is much less complex than
that of Glibc because you only have to fill in a few stubs of glue code.

These stubs of code include the system calls that are supposed to
call into the operating system you're running on. Because there's
no operating system proper, the simulator runs (on top of it) a proxy
kernel (`riscv-pk`) to handle many system calls, like `open`, `close`,
and `printf`.

[bibliography]
== References

- Waterman, A., Lee, Y., Patterson, D., and Asanovic, K,. "The RISC-V
Instruction Set Manual," vol. II,
https://inst.eecs.berkeley.edu/~cs152/sp12/handouts/riscv-supervisor.pdf,
2012.
- Bovet, D.P., and Cesati, M. _Understanding the Linux Kernel_, 3rd ed.,
O'Reilly, 2006.
- Gorman, M. _Understanding the Linux Virtual Memory Manager_,
http://www.csn.ul.ie/~mel/docs/vm/guide/pdf/understand.pdf, 2003.
- Corbet, J., Rubini, A., and Kroah-Hartman, G. _Linux Device Drivers_,
3rd ed., O'Reilly, 2005.
- Beekmans, G. _Linux From Scratch_, version 7.3,
http://www.linuxfromscratch.org/lfs/view/stable/, 2013.
- This document was originally authored by
https://ocf.berkeley.edu/~qmn[Quan Nguyen] and is available, in two
parts, at https://ocf.berkeley.edu/~qmn/linux/install-newlib.html and
https://ocf.berkeley.edu/~qmn/linux/install.html; recent updates were
made by Sagar Karandikar.
