= riscv-tools image:https://travis-ci.org/riscv/riscv-tools.svg?branch=master["Build Status",link="https://travis-ci.org/riscv/riscv-tools"]
:toc: macro
:toclevels: 1


The RISC-V toolchain is a set of tools for developing software on the
https://riscv.org[RISC-V] instruction set architecture; it consists of
the following components:

.RISC-V toolchain
 * https://github.com/riscv/riscv-fesvr[riscv-fesvr]
    a "front-end" server
 * https://github.com/riscv/riscv-gnu-toolchain[riscv-gnu-toolchain] a RISC-V cross-compiler
     image:https://travis-ci.org/riscv/riscv-gnu-toolchain.svg?branch=master["Build Status",link="https://travis-ci.org/riscv/riscv-gnu-toolchain"]
   - https://github.com/riscv/riscv-binutils-gdb[riscv-binutils-gdb] port of GNU Debugger
   - https://github.com/riscv/riscv-dejagnu[riscv-dejagnu] testing framework
   - https://github.com/riscv/riscv-gcc[riscv-gcc] port of the GNU Compiler Collection
   - https://github.com/riscv/riscv-glibc[riscv-glibc] GNU C Library
   - https://github.com/riscv/riscv-newlib[riscv-newlib] Newlib C Library
 * https://github.com/riscv/riscv-isa-sim[riscv-isa-sim]
    Spike, a RISC-V ISA simulator
 * https://github.com/riscv/riscv-llvm[riscv-llvm]
    low lever virtual machine image:https://travis-ci.org/riscv/riscv-llvm.svg?branch=riscv-trunk["Build Status",link="https://travis-ci.org/riscv/riscv-llvm"]
 * https://github.com/riscv/riscv-opcodes[riscv-opcodes]
    the RISC-V opcodes executable by the simulator
 * https://github.com/riscv/riscv-openocd[riscv-openocd]
    onchip programming and debugging image:https://travis-ci.org/riscv/riscv-openocd.svg?branch=riscv["Build Status",link="https://travis-ci.org/riscv/riscv-openocd"]
 * https://github.com/riscv/riscv-pk[riscv-pk]
    a proxy kernel for the RISC-V Newlib port
 * https://github.com/riscv/riscv-tests[riscv-tests]
    a set of assembly tests and benchmarks

'''

toc::[]

This repo provides two options for developing with RISC-V:
one installs the all of the `riscv-tools` along with the
https://github.com/riscv/riscv-newlib/[`riscv-newlib`] library using
the https://github.com/riscv/riscv-pk[`riscv-pk`] proxy kernel
and the other installs only a subset of the `riscv-tools` with
https://github.com/riscv/riscv-glibc[`riscv-glibc`] library using the
https://github.com/riscv/riscv-linux[`riscv-linux`] kernel.

Both options share a common setup but diverge around the time the
`build.sh` script is executed; simply follow this guide from the start
and we will let you know what to do based on the path you've chosen (you
can, of course, do both).

If you run into any troubles along the way, check the
link:Troubleshooting.html[Troubleshooting] document and the
https://github.com/riscv/riscv-tools/issues[issues] page on GitHub.


== Quickstart

    $ git clone --recursive https://github.com/riscv/riscv-tools
    $ ./build.sh <path/to/install/the/riscv/toolchain>

=== Dependencies

Ubuntu:

    # apt-get install autoconf automake autotools-dev curl device-tree-compiler libmpc-dev libmpfr-dev libgmp-dev libusb-1.0-0-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev device-tree-compiler pkg-config

Fedora:

    # dnf install autoconf automake @development-tools curl dtc libmpc-devel mpfr-devel gmp-devel gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib-devel

OS X:

    # brew install dtc gawk gnu-sed gmp mpfr libmpc isl wget automake md5sha1sum

NOTE: For OS X, you can also install the tools with
https://github.com/riscv/homebrew-riscv[homebrew-riscv]. This repo will build
with Apple's command-line developer tools (clang) in addition to gcc.


=== C++11 Compiler Support

Building `riscv-tools` requires a compiler with support for C++11 (e.g.,
GCC >= 4.8). To use a compiler different than your system default, set
the `CC` and `CXX` environment variables before running the `build.sh`
script:

    $ CC=gcc-4.8 CXX=g++-4.8 ./build.sh <directory>

== Setup

[NOTE]
====
Build times have been provided in terms of the
http://linuxfromscratch.org/lfs/view/stable/chapter04/aboutsbus.html[Standard
Build Unit] (SBU).
====

=== Obtaining and Compiling the Sources (7.87 SBU)

Clone the `riscv-tools` repository along with all of the submodules:

    $ git clone --recursive https://github.com/riscv/riscv-tools


== pk/Newlib Installation

IMPORTANT: This command will build the the full `riscv-tools` set; you
don't *need* `riscv-newlib` and `riscv-pk` if you only want to develop
on the `riscv-linux` kernel with the `riscv-glib` library; see the
<<Linux/Glibc Installation>> section for more information.

Run the `build.sh` script to install all of the tools to <directory>:

    $ ./build.sh <directory>

To see all of the available options, run with the `-h` flag: `./build.sh
-h`.

[WARNING]
====
In order for your shell to find the tools, the `<directory>/bin`
subdirectory must be in your `PATH` environment variable; add it with

    $ export PATH:$PATH:<directory>/bin
====


=== Testing Your Toolchain

Let's test our new toolchain on the quintessential "Hello world!" program:

.hello.c
----
#include <stdio.h>
int main(void) {
    printf("Hello world!\n");
    return 0;
}
----

Build it with the cross-compiler:

    $ riscv64-unknown-elf-gcc -o hello hello.c

You may want to do `./hello` -- but not so fast! We can't even run `spike
hello`, because our "Hello world!" program makes a system call which the
host x86 system doesn't understand. We have to run the program within the
proxy kernel, which itself is run by `spike`, the RISC-V architectural
simulator. Run this command to execute your "Hello world!" program:

    $ spike pk hello

NOTE: The RISC-V architectural simulator, `spike`, takes as its argument the
path of the binary to run. Then, `pk` receives as _its_ argument the
name of the program you want to run.

Now you're all set to develop on the RISC-V instruction set architecture
with `riscv-newlib` and the proxy kernel!


== Linux/Glibc Installation

IMPORTANT: This section is only required for developing RISC-V on the
`riscv-linux` kernel with the `riscv-glibc` library (otherwise, you can
use the `riscv-pk` kernel with the `riscv-newlib` library).

=== Installing the RISC-V simulator & Building the Cross-Compiler (11.81 SBU)

Instead of building all of the tools in the `riscv-tools` set, we only
need to build `riscv-fesvr`, `riscv-isa-sim` and the `riscv-gnu-toolchain`
(configured for `riscv-linux`).

NOTE: If you want to build the full toolchain for later use, run
`build.sh <directory> all linux` instead.

Let's build only the tools we need:

    $ ./build.sh <directory> linux

The `linux` argument builds `riscv64-unknown-linux-gnu-gcc`,the
cross-compiler used to build binaries linked to `riscv-glibc`; you can
pass the `-j[number]` flag after `linux` to build concurrently.


=== Building the Linux Kernel (0.40 + ε SBU)

==== Obtaining the Kernel Sources

We are finally poised to bring in the `riscv-linux` kernel sources:

    $ cd ..
    $ git clone https://github.com/riscv/riscv-linux

==== Configuring the Linux Kernel

The Linux kernel is seemingly infinitely-configurable. However, with the
current development status of RISC-V, there aren't that many devices or
options to tweak. So starting with a default configuration should work
out-of-the-box with the ISA simulator.

    $ cd riscv-linux
    $ make ARCH=riscv defconfig   # or menuconfig to change the configuration

Among other things, we have enabled by default: procfs, ext2, and the
HTIF virtualized devices (a block driver and console).

TIP: In development, it can be very useful to enable `Kernel hacking`
→ `Early printk`, which will print messages to the console if the
kernel crashes very early.

Once you're satisfied with your configuration, begin building the
kernel.

WARNING: To build the RISC-V kernel, you _must_ set the `ARCH` variable
to `riscv` in each invocation of `make`.

TIP: If you want to speed up the process, you can pass the `-j[number]`
option to use `[number]` threads.

    $ make -j4 ARCH=riscv

Congratulations! You've just cross-compiled the Linux kernel for RISC-V.
However, there are a few more things to take care of before we boot it.

=== Building BusyBox (0.26 SBU)

We currently develop with https://www.busybox.net[BusyBox], an
unbelievably useful set of utilities that all compile into one multi-use
binary.

First, obtain and untar the source:

    $ cd ..
    $ curl -L http://busybox.net/downloads/busybox-1.26.2.tar.bz2 | tar xjf -

Then, enter that directory and turn off every configuration option:

    $ cd busybox-1.26.2
    $ make allnoconfig

Enter the configuration interface,

    $ make menuconfig

and change the following options (don't set `CONFIG_STATIC` if you want
to compile dynamically):

`CONFIG_STATIC=y`::
    BusyBox Settings → Build Options → Build BusyBox as a static binary (no shared libs)
`CONFIG_CROSS_COMPILER_PREFIX=riscv64-unknown-linux-gnu-`::
    BusyBox Settings → Build Options → Cross Compiler prefix
`CONFIG_FEATURE_INSTALLER=y`::
    BusyBox Setting → General Configuration → Support --install [-s] to install applet links at runtime
`CONFIG_INIT=y`::
    Init utilities → init
`CONFIG_ASH=y`::
    Shells → ash 
`CONFIG_ASH_JOB_CONTROL=n`::
    Shells → Ash → Job control
`CONFIG_MOUNT=y`::
    Linux System Utilities → mount
`CONFIG_FEATURE_USE_INITTAB=y`::
    Init Utilities → Support reading an inittab file

Once you've finished, compile BusyBox.

TIP: You don't need to specify `ARCH` here, because we've already passed
the name of the cross-compiler prefix.

    $ make -j4

Once that completes, you'll have a BusyBox binary cross-compiled to
run on RISC-V. 

Now configure linux to use a root disk image so the kernel has access
to the binary:

    $ cd riscv-linux
    $ make ARCH=riscv menuconfig

``::
General Setup → "Initial RAM filesystem and RAM disk"
``::
General Setup → "Initramfs source file" → "../riscv-tools/initramfs.txt"

Don't forget to rebuild `riscv-linux` and `riscv-pk`!

    $ make -j4 ARCH=riscv vmlinux
    $ ./build.sh <directory> pk --host=riscv64-unknown-linux-gnu --with-payload=<riscv-linux>/vmlinux

Now, we're ready to boot a most basic kernel, with a shell. Invoke
`spike` to use the `bbl` binary to run the `vmlinux` compiled Linux
kernel.

    $ spike bbl vmlinux

If there are no problems, an `ash` prompt will appear after the boot
process completes. It will be pretty useless without the usual plethora
of command-line utilities, but you can add them as BusyBox applets. Have
fun and report back!

To exit the simulator, kill the current process with `Ctrl-C`.


== FAQ

=== What's Newlib?

https://www.sourceware.org/newlib/[Newlib] is a "C library intended for
use on embedded systems." It has the advantage of not having so much cruft
as Glibc at the obvious cost of incomplete support (and idiosyncratic
behavior) in the fringes. The porting process is much less complex than
that of Glibc because you only have to fill in a few stubs of glue code.

These stubs of code include the system calls that are supposed to
call into the operating system you're running on. Because there's
no operating system proper, the simulator runs (on top of it) a proxy
kernel (`riscv-pk`) to handle many system calls, like `open`, `close`,
and `printf`.

[bibliography]
== References

- Waterman, A., Lee, Y., Patterson, D., and Asanovic, K,. "The RISC-V
Instruction Set Manual," vol. II,
https://inst.eecs.berkeley.edu/~cs152/sp12/handouts/riscv-supervisor.pdf,
2012.
- Bovet, D.P., and Cesati, M. _Understanding the Linux Kernel_, 3rd ed.,
O'Reilly, 2006.
- Gorman, M. _Understanding the Linux Virtual Memory Manager_,
http://www.csn.ul.ie/~mel/docs/vm/guide/pdf/understand.pdf, 2003.
- Corbet, J., Rubini, A., and Kroah-Hartman, G. _Linux Device Drivers_,
3rd ed., O'Reilly, 2005.
- Beekmans, G. _Linux From Scratch_, version 7.3,
http://www.linuxfromscratch.org/lfs/view/stable/, 2013.
- This document was originally authored by
https://ocf.berkeley.edu/~qmn[Quan Nguyen] and is available, in two
parts, at https://ocf.berkeley.edu/~qmn/linux/install-newlib.html and
https://ocf.berkeley.edu/~qmn/linux/install.html; recent updates were
made by Sagar Karandikar.

