= riscv-tools image:https://travis-ci.org/riscv/riscv-tools.svg?branch=master["Build Status",link="https://travis-ci.org/riscv/riscv-tools"]
:toc: macro
:toclevels: 1


The RISC-V toolchain is a set of tools for developing software on the
https://riscv.org[RISC-V] instruction set architecture; it consists of
the following components:

.RISC-V toolchain
 * https://github.com/riscv/riscv-fesvr[riscv-fesvr]
    a "front-end" server
 * https://github.com/riscv/riscv-gnu-toolchain[riscv-gnu-toolchain] a RISC-V cross-compiler
     image:https://travis-ci.org/riscv/riscv-gnu-toolchain.svg?branch=master["Build Status",link="https://travis-ci.org/riscv/riscv-gnu-toolchain"]
   - https://github.com/riscv/riscv-binutils-gdb[riscv-binutils-gdb] port of GNU Debugger
   - https://github.com/riscv/riscv-dejagnu[riscv-dejagnu] testing framework
   - https://github.com/riscv/riscv-gcc[riscv-gcc] port of the GNU Compiler Collection
   - https://github.com/riscv/riscv-glibc[riscv-glibc] GNU C Library
   - https://github.com/riscv/riscv-newlib[riscv-newlib] Newlib C Library
 * https://github.com/riscv/riscv-isa-sim[riscv-isa-sim]
    Spike, a RISC-V ISA simulator
 * https://github.com/riscv/riscv-llvm[riscv-llvm]
    low lever virtual machine image:https://travis-ci.org/riscv/riscv-llvm.svg?branch=riscv-trunk["Build Status",link="https://travis-ci.org/riscv/riscv-llvm"]
 * https://github.com/riscv/riscv-opcodes[riscv-opcodes]
    the RISC-V opcodes executable by the simulator
 * https://github.com/riscv/riscv-openocd[riscv-openocd]
    onchip programming and debugging image:https://travis-ci.org/riscv/riscv-openocd.svg?branch=riscv["Build Status",link="https://travis-ci.org/riscv/riscv-openocd"]
 * https://github.com/riscv/riscv-pk[riscv-pk]
    a proxy kernel for the RISC-V Newlib port
 * https://github.com/riscv/riscv-tests[riscv-tests]
    a set of assembly tests and benchmarks

'''

toc::[]

This repo provides two guides: one installs the all of the `riscv-tools`
along with the https://github.com/riscv/riscv-newlib/[`riscv-newlib`]
library using the https://github.com/riscv/riscv-pk[`riscv-pk`]
proxy kernel and the other installs only a subset of the `riscv-tools`
with https://github.com/riscv/riscv-glibc[`riscv-glibc`] using the
https://github.com/riscv/riscv-linux[`riscv-linux`] kernel.

Both options share a common setup but diverge around the time the
`build.sh` script is executed; simply follow this guide from the start
and we will let you know what to do based on the path you've chosen
(you can, of course, do both).


== Quickstart

    $ git submodule update --init --recursive
    $ export RISCV=/path/to/install/the/riscv/toolchain
    $ ./build.sh

=== Dependencies

Ubuntu:

    # apt-get install autoconf automake autotools-dev curl device-tree-compiler libmpc-dev libmpfr-dev libgmp-dev libusb-1.0-0-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev device-tree-compiler pkg-config

Fedora:

    # dnf install autoconf automake @development-tools curl dtc libmpc-devel mpfr-devel gmp-devel gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib-devel

OS X:

    # brew install dtc gawk gnu-sed gmp mpfr libmpc isl wget automake md5sha1sum

NOTE: For OS X, you can also install the tools with
https://github.com/riscv/homebrew-riscv[homebrew-riscv]. This repo will build
with Apple's command-line developer tools (clang) in addition to gcc.


=== C++11 Compiler Support

Building `riscv-tools` requires a compiler with support for C++11 (e.g.,
GCC >= 4.8). To use a compiler different than your system default, set
the `CC` and `CXX` environment variables before running the `build.sh`
script:

    $ CC=gcc-4.8 CXX=g++-4.8 ./build.sh

== Setup

[NOTE]
====
Build times have been provided in terms of the
http://linuxfromscratch.org/lfs/view/stable/chapter04/aboutsbus.html[Standard
Build Unit] (SBU).
====

=== Obtaining and Compiling the Sources (7.87 SBU)

Let's start by defining the directory in which we will install all of
the necessary programs, let's call it `RISCV` and go there:

    $ export RISCV=/nice/big/directory
    $ cd $RISCV

The tools will be installed to `RISCV/build`.


[WARNING]
====
If this does not place the `$RISCV/build/bin` subdirectory in your `PATH`
environment variable, add it now:

    $ export PATH=$PATH:$RISCV/build/bin
====

Now clone the `riscv-tools` repository:

    $ git clone https://github.com/riscv/riscv-tools

This command will only bring in submodule references to the repositories
that we will need. Enter the newly-created riscv-tools directory and
instruct Git to update all of the submodules.

    $ cd riscv-tools
    $ git submodule update --init --recursive


== pk/Newlib Installation

IMPORTANT: This section is only necessary if you want to use the full
`riscv-tools` set (mainly, `riscv-newlib` and the `riscv-pk`); otherwise,
skip down to the <<Linux/Glibc Installation>> section.

With everything else set up, run the `build.sh` script:

    $ ./build.sh

=== Testing Your Toolchain

Now that you have a toolchain, it'd be a good idea to test it on the
quintessential "Hello world!" program:

.hello.c
----
#include <stdio.h>
int main(void) {
    printf("Hello world!\n");
    return 0;
}
----

Build it with the cross-compiler:

    $ riscv64-unknown-elf-gcc -o hello hello.c

You may want to do `./hello` -- but not so fast. We can't even run `spike
hello`, because our "Hello world!" program makes a system call which the
host x86 system doesn't understand. We have to run the program within the
proxy kernel, which itself is run by `spike`, the RISC-V architectural
simulator. Run this command to execute your "Hello world!"  program:

    $ spike pk hello

NOTE: The RISC-V architectural simulator, `spike`, takes as its argument the
path of the binary to run. Then, `pk` receives as _its_ argument the
name of the program you want to run.

If this does not behave as expected, see the <<Troubleshooting>> section
below. Otherwise, you're all set to develop on the RISC-V instruction
set architecture with `riscv-newlib` and the proxy kernel!

== Linux/Glibc Installation

IMPORTANT: This section is only required for developing RISC-V on the
`riscv-linux` kernel with the `riscv-glibc` library.

=== Installing the RISC-V simulator (0.40 SBU)

Instead of building all of the tools in the `riscv-tools` set, we only
need to build `riscv-fesvr` and `riscv-isa-sim`.

NOTE: If you want to build the full toolchain for later use, run
`build.sh` without any arguments as done in the <<pk/Newlib Installation>>
section.

Let's build only the tools we need:

    $ ./build.sh fesvr isa-sim

=== Building the Cross-Compiler (11.41 SBU)

`riscv64-unknown-linux-gnu-gcc` is the cross-compiler used to build
binaries linked to the GNU C Library (`glibc`); configure it for your
system with:

    $ cd $RISCV/riscv-tools/riscv-gnu-toolchain
    $ ./configure --prefix=$RISCV/build

These instructions will place your `riscv64-unknown-linux-gnu-gcc`
tools in the same directory as the `riscv64-unknown-elf-gcc`.

Run the `linux` make target to start the build process:

    $ make linux

=== Building the Linux Kernel (0.40 + ε SBU)

==== Obtaining the Kernel Sources

We are finally poised to bring in the `riscv-linux` kernel sources. Let's
put it with the rest of our programs at `RISCV`:

    $ cd $RISCV
    $ git clone https://github.com/riscv/riscv-linux

==== Configuring the Linux Kernel

The Linux kernel is seemingly infinitely-configurable. However, with the
current development status of RISC-V, there aren't that many devices or
options to tweak. So starting with a default configuration should work
out-of-the-box with the ISA simulator.

    $ cd riscv-linux
    $ make ARCH=riscv defconfig

If you want to change the default configuration, you can use a text-based
GUI (ncurses) to edit the configuration:

    $ make ARCH=riscv menuconfig

Among other things, we have enabled by default: procfs, ext2, and the
HTIF virtualized devices (a block driver and console).

TIP: In development, it can be very useful to enable "early printk",
which will print messages to the console if the kernel crashes very
early. You can access this option at "Early printk" in the "Kernel
hacking" submenu.

Once you're satisfied with your configuration, begin building the
kernel.

WARNING: to build the RISC-V kernel, you _must_ set the `ARCH` variable
to `riscv` in each invocation of `make`.

If you want to speed up the process, you can pass the `-j[number]`
option to use `[number]` threads.

    $ make -j16 ARCH=riscv

Congratulations! You've just cross-compiled the Linux kernel for RISC-V.
However, there are a few more things to take care of before we boot it.

=== Building BusyBox (0.26 SBU)

We currently develop with https://www.busybox.net[BusyBox], an
unbelievably useful set of utilities that all compile into one multi-use
binary.

First, obtain and untar the source:

    $ curl -L http://busybox.net/downloads/busybox-1.26.2.tar.bz2 | tar xjf -

Then, enter the directory and turn off every configuration option:

    $ cd busybox-1.26.2
    $ make allnoconfig

Enter the configuration interface,

    $ make menuconfig

and change the following options (don't set `CONFIG_STATIC` if you want
to compile dynamically):

`CONFIG_STATIC=y`::
    BusyBox Settings → Build Options → Build BusyBox as a static binary (no shared libs)
`CONFIG_CROSS_COMPILER_PREFIX=riscv64-unknown-linux-gnu-`::
    BusyBox Settings → Build Options → Cross Compiler prefix
`CONFIG_FEATURE_INSTALLER=y`::
    BusyBox Setting → General Configuration → Support --install [-s] to install applet links at runtime
`CONFIG_INIT=y`::
    Init utilities → init
`CONFIG_ASH=y`::
    Shells → ash 
`CONFIG_ASH_JOB_CONTROL=n`::
    Shells → Ash → Job control
`CONFIG_MOUNT=y`::
    Linux System Utilities → mount
`CONFIG_FEATURE_USE_INITTAB=y`::
    Init Utilities → Support reading an inittab file

Once you've finished, compile BusyBox.

TIP: You don't need to specify `ARCH` here, because we've already passed
the name of the cross-compiler prefix.

    $ make -j16

Once that completes, you'll have a BusyBox binary cross-compiled to
run on RISC-V. Now let's create a root disk image that will allow the
kernel access to the binary.

=== Creating a Root Disk Image

We use an initramfs to store our binaries. Use the `mkroot.sh` script
to create the root disk image (run `./mkroot.sh -h` to see all of
the available options):

    $ cd $RISCV
    $ ./mkroot.sh

[TIP]
====
`mkroot.sh` creates symlinks that will persist between boots. This
will cause a bunch of unsightly errors in every subsequent boot of
the kernel. To get rid of them, comment out (or delete) this line of
`mnt/etc/inittab` after the first boot:

    ::sysinit:/bin/busybox --install -s
====

Now configure linux to embed the new rootfs:

    $ cd riscv-linux
    $ make ARCH=riscv menuconfig

``::
General Setup → "Initial RAM filesystem and RAM disk"
``::
General Setup → "Initramfs source file" → "rootfs.cpio"

Don't forget to rebuild `riscv-linux` and `riscv-pk`!

    $ make -j4 ARCH=riscv vmlinux
    $ cd $RISCV
    $ ./build.sh pk --host=riscv64-unknown-linux-gnu --with-payload=$RISCV/riscv-linux/vmlinux

Now, we're ready to boot a most basic kernel, with a shell. Invoke
`spike` to use the `bbl` binary to run the `vmlinux` compiled Linux
kernel.

    $ spike bbl vmlinux

If there are no problems, an `ash` prompt will appear after the boot
process completes. It will be pretty useless without the usual plethora
of command-line utilities, but you can add them as BusyBox applets. Have
fun and report back!

To exit the simulator, kill the current process with `Ctrl-C`.


== Troubleshooting

Most of the errors below were seen when trying to build `riscv-tools` on
a CentOS linux distribution with nfs file-system.


=== Installing a Fresh Copy of the Linux Headers

If your Linux system headers have been changed, you'll need
to install a new version to your system root before you build
`riscv64-unknown-linux-gnu-gcc` to ensure the kernel and the C library
agree on their interfaces.

First, go to the Linux directory and perform a headers check:

    $ cd $RISCV/riscv-linux
    $ make ARCH=riscv headers_check

Once the headers have been checked, install them.

    $ make ARCH=riscv headers_install INSTALL_HDR_PATH=$RISCV/build/sysroot64/usr


=== C++11 is not supported, although gcc is updated

This problem occured due to old OS installation repository. A possible
solution for CentOS distribution:

    $ wget http://people.centos.org/tru/devtools-2/devtools-2.repo -O /etc/yum.repos.d/devtools-2.repo
    # yum upgrade
    # yum install devtoolset-2-gcc devtoolset-2-binutils devtoolset-2-gcc-c++
    $ scl enable devtoolset-2 bash

Last operation will open a shell. Try to run `build.sh` from within this
shell.

=== error: Building GCC requires GMP 4.2+, MPFR 2.4.0+ and MPC 0.8.0+

Try the following:

    $ cd $RISCV/riscv-tools/riscv-gnu-toolchain/riscv-gcc
    $ contrib/download_prerequisites
    # yum install gmp gmp-devel mpfr mpfr-devel libmpc libmpc-devel

Also be sure you have <<C++11 Compiler Support>>.

=== Build script got stuck on "Installing project riscv-fesvr"

That's a problem of output redirection. Open the `build.sh` file and
change the following line:

    $MAKE install >> build.log

to:

    $MAKE install | tee install.log

Then when you run the build script, you will see requests to press y to
continue which were hidden before.

=== Problems with "flock"

Some filesystems don't support flock, e.g. nfs (you can check your
filesystem with `df -Th`). Delete `+flock $(SYSROOT)/.lock` in the
following files:

 * `riscv-tools/riscv-gnu-toolchain/Makefile`
 * `riscv-tools/riscv-gnu-toolchain/Makefile.in`
 * `riscv-tools/riscv-gnu-toolchain/build/Makefile`

Avoid building with concurrency (i.e. avoid running make with the
-j flag).

=== These critical programs are missing or too old: make

Not sure why, but gmake doesn't work well for the `riscv-tools` build on
some platforms. In order to use make instead of gmake, open the file
`$RISCV/riscv-tools/riscv-gnu-toolchain/riscv-glibc/configure` and replace
the following line:

    for ac_prog in gnumake gmake make

with:

    for ac_prog in gnumake make gmake

=== "Operation not permitted" when trying to create character device

This may occur when running the following command:

    # mknod dev/console c 5 1

Even if you have superuser permissions, you may still see this message
in some filesystems (e.g., nfs). You can create a virtual drive with:

    $ dd if=/dev/zero of=root.bin bs=1M count=64
    $ mkfs.ext2 -F root.bin
    $ chmod 777 root.bin
    $ mkdir mnt
    # mount -o loop root.bin mnt

If the `mkfs.ext2` command is not found, try instead:

    $ /sbin/mkfs.ext2 -F root.bin

Copy the contents in the above created `root` directory into the new `mnt`
directory and continue to create the cpio archive with the `mnt` directory
instead of the `root` directory.

When finished, you may unmount by:

    $ cd ..
    # umount root.bin

=== Error on build about "mcmodel=medany"

Such error may occur in one of the stages that requires the RISC-V gcc
compiler. Some build stages use the default x86 gcc compiler installed
on the x86 machine to compile if the RISC-V gcc not found. Some possible
cases for that:

 * $RISCV/build/bin is not in $PATH
 * RISC-V compiler is not built or has been for the wrong variant (built for
newlib and not for linux, 32/64 bit variant issue...).
 * gcc path is wrong. For example, if
`CONFIG_CROSS_COMPILER_PREFIX=riscv-linux-` is used in the Busybox build
configuration instead of
`CONFIG_CROSS_COMPILER_PREFIX=riscv64-unknown-linux-gnu-` but the RISC-V
compiler is built into riscv64-unknown-linux-gnu-gcc, the busybox
configurator will not find the correct gcc and will use the x86 as
default. Similar problem may occur when compiling
`riscv-pk` with a wrong --host argument.

=== Spike exits immediately with "This is bbl's dummy_payload" message

`riscv-pk` should be rebuilt with `--with-payload` flag that points to
the compiled vmlinux:

    $ ./build.sh pk --host=riscv64-unknown-linux-gnu --with-payload=$RISCV/riscv-linux/vmlinux

== FAQ

=== What's Newlib?

https://www.sourceware.org/newlib/[Newlib] is a "C library intended for
use on embedded systems." It has the advantage of not having so much cruft
as Glibc at the obvious cost of incomplete support (and idiosyncratic
behavior) in the fringes. The porting process is much less complex than
that of Glibc because you only have to fill in a few stubs of glue code.

These stubs of code include the system calls that are supposed to
call into the operating system you're running on. Because there's
no operating system proper, the simulator runs (on top of it) a proxy
kernel (`riscv-pk`) to handle many system calls, like `open`, `close`,
and `printf`.

[bibliography]
== References

- Waterman, A., Lee, Y., Patterson, D., and Asanovic, K,. "The RISC-V
Instruction Set Manual," vol. II,
https://inst.eecs.berkeley.edu/~cs152/sp12/handouts/riscv-supervisor.pdf,
2012.
- Bovet, D.P., and Cesati, M. _Understanding the Linux Kernel_, 3rd ed.,
O'Reilly, 2006.
- Gorman, M. _Understanding the Linux Virtual Memory Manager_,
http://www.csn.ul.ie/~mel/docs/vm/guide/pdf/understand.pdf, 2003.
- Corbet, J., Rubini, A., and Kroah-Hartman, G. _Linux Device Drivers_,
3rd ed., O'Reilly, 2005.
- Beekmans, G. _Linux From Scratch_, version 7.3,
http://www.linuxfromscratch.org/lfs/view/stable/, 2013.
- This document was originally authored by
https://ocf.berkeley.edu/~qmn[Quan Nguyen] and is available, in two
parts, at https://ocf.berkeley.edu/~qmn/linux/install-newlib.html and
https://ocf.berkeley.edu/~qmn/linux/install.html; recent updates were
made by Sagar Karandikar.
